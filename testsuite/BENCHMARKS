Integrate cexp from 0 to 10000 using FixedRK4, no output.
Compilation flags: -O3 -funroll-loops

zuni: 

  dxsav		t_u (s)
    0.0		12.19	12.04	12.01	12.22
    0.01	18.07	17.96	18.00	18.07
    0.1		12.25	12.30	12.27	12.27
    1.0		11.77	11.78	11.77	11.78
   10.0		11.73	11.72   11.67   11.71
  100.0		11.79	11.82	11.76	11.73	
  500.0         11.97   11.87   11.87   11.99
 1000.0		11.85	12.04	12.03	11.85
10000.0		12.50	12.67	12.73	12.55

tejas:

  dxsav		t_u (s)
    0.0		14.46	14.23	14.26	14.27
    0.1		15.55	15.56	15.80	15.65
    1.0		14.95	14.97	15.14	15.01
   10.0		14.90	15.02	14.79	15.01
  100.0		15.00	14.94	14.97	15.46
 1000.0		14.91	14.86	14.91	14.99
10000.0		14.30	14.25	14.30	14.86

The data for tejas makes more sense: the dxsav=0 and dxsav=10000 are
very similar, since we are only saving two points for dxsav=10000.
Between that the time decreases from dxsav=0.1 to dxsav=10000, with a
plateau.

Integrate cexp from 0 to 10000 using AdaptiveRK4, no output.
Compilation flags: -O3 -funroll-loops

zuni:

  dxsav		t_u (s)
    0.0		4.49	4.47	4.48
    0.1		5.14	5.15	5.16
    1.0		4.60	4.57	4.58
   10.0		4.53	4.54	4.53
  100.0		4.53	4.53	4.53
 1000.0		4.54	4.53	4.55
10000.0		4.54	4.54	4.53

tejas:

  dxsav		t_u (s)
    0.0		5.54	5.56	5.55
    0.1		6.48	6.45	6.47
    1.0		5.78	5.71	5.72
   10.0		5.64	5.61	5.63
  100.0		5.59	5.63	5.66
 1000.0		5.60	5.60	5.60
10000.0		5.61	5.63	5.61

Much better!  Both make sense: steady decrease to the dxsav=0 value.

Okay: I've separated the integration from the data sampling.  The
results are similar:

tejas:

  dxsav		t_u (s)
   none		5.37	5.32	5.24	5.24
    0.1		7.17	7.26	7.28	7.25
    0.5		5.51	5.57	5.54	5.53
    1.0		5.47	5.46	5.47	5.52
   10.0		5.37	5.32	5.33	5.35
  100.0		5.34	5.35	5.34	5.34
10000.0		5.37	5.48	5.38	5.40

It's faster at the tail end (no data points saved), probably because
there are less conditionals than before.  However, for a lot of save
points (100000) it is noticeably slower than before (7.25-6.45=.8s).
Why is that?  It may be that there is the creation of a temporary when
operator() returns the value of vecT y in SolverBase.  The copying is
negligible for a reasonable number of data points.

Here are some comparisons of the above run for different optimizations
dxsav=0.1

tejas:
			t_u (s)
-O -funroll-loops	7.10
-O3 -funroll-loops	7.25
-O			7.49
-O3			7.79
-O2			7.86
-funroll-loops		22.57
none			22.43

Something in -O3 and -O2 is making things worse!  Peruse gcc.info-3 and try to find what it is.

1999/03/03:

Integrate s.h.o. to t=10000 (acc.=1e-10).

adaptiverk4		Use STL vector as container.
Vadaptiverk4		Use Vec as container.

Output of benchprog: (egcs-2.92.23 19981122 (gcc2 ss-980609 experimental))

Unoptimized
Program          min       max       avg       +/-     
-----------------------------------------------------
adaptiverk4      21.800    21.950    21.857    0.066   
Vadaptiverk4     16.680    16.720    16.697    0.017   

-O
Program          min       max       avg       +/-     
-----------------------------------------------------
adaptiverk4      4.940     4.960     4.954     0.008   
Vadaptiverk4     5.270     5.300     5.280     0.011   

-O2
Program          min       max       avg       +/-     
-----------------------------------------------------
adaptiverk4      4.960     4.990     4.970     0.014   
Vadaptiverk4     5.040     5.080     5.063     0.017   

-O3
Program          min       max       avg       +/-     
-----------------------------------------------------
adaptiverk4      4.940     4.960     4.948     0.010   
Vadaptiverk4     4.970     4.980     4.976     0.005   

-O3 -funroll-loops
Program          min       max       avg       +/-     
-----------------------------------------------------
adaptiverk4      4.010     4.080     4.034     0.025   
Vadaptiverk4     3.960     3.970     3.964     0.005   

Vec finally wins out at full optimization!

On zuni:

Unoptimized
Program          min       max       avg       +/-     
-----------------------------------------------------
adaptiverk4      24.050    24.060    24.057    0.005   
Vadaptiverk4     16.450    16.450    16.450    0.000   

-O
Program          min       max       avg       +/-     
-----------------------------------------------------
adaptiverk4      3.970     3.980     3.973     0.005   
Vadaptiverk4     4.070     4.070     4.070     0.000   

-O2
Program          min       max       avg       +/-     
-----------------------------------------------------
adaptiverk4      3.950     3.950     3.950     0.000   
Vadaptiverk4     3.720     3.730     3.723     0.005   

-O3
Program          min       max       avg       +/-     
-----------------------------------------------------
adaptiverk4      3.940     3.950     3.947     0.005   
Vadaptiverk4     3.730     3.730     3.730     0.000   

-O3 -funroll-loops
Program          min       max       avg       +/-     
-----------------------------------------------------
adaptiverk4      2.930     2.940     2.938     0.004   
Vadaptiverk4     2.920     2.930     2.926     0.005   

Vec does better on zuni!

=====================================================

1999/03/04

Here's a cool test: Numerical recipes in C vs rodent.
Integrate s.h.o. to t=10000, accuracy 1.e-10. No data points saved.

egcs-2.92.23 19981122 (gcc2 ss-980609 experimental)

adaptiverk4	Rodent, rk4
shoint		NRC odeint, rkck, rkqs.

tejas:

-O
Program               avg       +/-       min       max     
---------------------------------------------------------
adaptiverk4           5.048     0.019     5.020     5.070   
shoint                6.052     0.032     6.020     6.110   
shoint                6.060     0.033     6.030     6.120   gcc 2.7.2.3

-O -funroll-loops
Program               avg       +/-       min       max     
---------------------------------------------------------
adaptiverk4           4.181     0.017     4.160     4.220   
shoint                6.187     0.009     6.180     6.210   

-O2
Program               avg       +/-       min       max     
---------------------------------------------------------
adaptiverk4           5.064     0.010     5.050     5.080   
shoint                6.288     0.036     6.270     6.360   
shoint                6.274     0.014     6.260     6.290   gcc 2.7.2.3

-O2 -funroll-loops
Program               avg       +/-       min       max     
---------------------------------------------------------
adaptiverk4           4.098     0.015     4.080     4.120   
shoint                6.640     0.006     6.630     6.650   
shoint                6.676     0.039     6.630     6.730   gcc 2.7.2.3

-O3 -funroll-loops
Program               avg       +/-       min       max     
---------------------------------------------------------
adaptiverk4           4.108     0.012     4.090     4.120   
shoint                6.586     0.014     6.570     6.600   
shoint                6.664     0.071     6.570     6.770   gcc 2.7.2.3

rodent is the clear winner!  Not sure whether this is due to the
different method used in NRC, though.

rodent	10000   -0.3056143912	-0.952155376
nrc	10000	-0.3056144457	-0.9521555346
exact	10000	-0.3056143889	-0.9521553683

Rodent also gets one more digit right.

zuni:

-O
Program               avg       +/-       min       max     
---------------------------------------------------------
adaptiverk4           4.074     0.005     4.070     4.080   
shoint                4.708     0.007     4.700     4.720   

-O2
Program               avg       +/-       min       max     
---------------------------------------------------------
adaptiverk4           3.960     0.000     3.960     3.960   
shoint                4.706     0.005     4.700     4.710   

-O3
Program               avg       +/-       min       max     
---------------------------------------------------------
adaptiverk4           3.960     0.000     3.960     3.960   
shoint                4.710     0.000     4.710     4.710   

-O3 -funroll-loops
Program               avg       +/-       min       max     
---------------------------------------------------------
adaptiverk4           2.976     0.005     2.970     2.980   
shoint                4.708     0.004     4.700     4.710   

rodent still kicks ass!

=========================================================
1999/03/04

I finally got aniso to run with rodent.  So now I have a sizeable code
to try this on.  The runs are for no saved points, 4 modes (12
variables), from t = 0 to 100, with accuracy 1.e-6.  The following
parameter values were used:

k    1.000000
p1   1.000000
p2   -1.100000
p3   1.000000
p4   1.000000
q1   -0.930864
q2   0.000000
q3   4.269136
q4   0.000000
q5   2.000000
q6   -10.000000
q7   1.000000
q8   6.112238
q9   4.273177

Program               avg       +/-       min       max     
---------------------------------------------------------
anisoO                4.153     0.005     4.150     4.160   
anisoO2               4.613     0.005     4.610     4.620   
anisoO3               4.627     0.009     4.620     4.640   
anisoO2un             4.667     0.005     4.660     4.670   
anisoO3un             4.677     0.005     4.670     4.680   
aniso                 8.237     0.005     8.230     8.240   
anisoun               8.263     0.034     8.230     8.310   

Sadly, I can't really compare with old runs... but they seem MUCH
faster.  CVODE must use a very good algorithm.  Stiff?  Need to
implement implicit methods...

=========================================================
1999/03/05

Iterators vs explicit loops: I've added a flag RODENT_NO_ITERATOR_LOOPS
which switches iterators on and off.  Here are the timings:

(egcs-2.92.23 19981122 (gcc2 ss-980609 experimental))

tejas:

Program               avg       +/-       min       max     
---------------------------------------------------------
Iterators:
adaptiverk4O2         4.680     0.016     4.660     4.700   
adaptiverk4O3un       4.817     0.025     4.790     4.850   
adaptiverk4O2un       4.827     0.083     4.710     4.900   
adaptiverk4O3         4.853     0.033     4.830     4.900   
adaptiverk4Oun        4.890     0.036     4.860     4.940   
adaptiverk4O          4.897     0.009     4.890     4.910   

No iterators:
adaptiverk4NoItOun    5.090     0.014     5.070     5.100   
adaptiverk4NoItO3un   5.160     0.008     5.150     5.170   
adaptiverk4NoItO3     5.163     0.005     5.160     5.170   
adaptiverk4NoItO2un   5.180     0.022     5.160     5.210   
adaptiverk4NoItO2     5.190     0.029     5.160     5.230   
adaptiverk4NoItO      5.230     0.016     5.210     5.250   

Iterators are uniformly better!

Pretty much the same story on zuni:

Program               avg       +/-       min       max     
---------------------------------------------------------
adaptiverk4O3         3.710     0.000     3.710     3.710   
adaptiverk4O2         3.710     0.000     3.710     3.710   
adaptiverk4O3un       3.713     0.005     3.710     3.720   
adaptiverk4O2un       3.713     0.005     3.710     3.720   
adaptiverk4NoItO3un   3.807     0.005     3.800     3.810   
adaptiverk4NoItO2un   3.810     0.000     3.810     3.810   
adaptiverk4NoItO2     3.810     0.000     3.810     3.810   
adaptiverk4NoItO3     3.810     0.008     3.800     3.820   
adaptiverk4Oun        3.853     0.005     3.850     3.860   
adaptiverk4O          3.857     0.005     3.850     3.860   
adaptiverk4NoItO      4.000     0.000     4.000     4.000   
adaptiverk4NoItOun    4.063     0.005     4.060     4.070   

Something bad has happened, though: now both tejas and zuni get slower
results than on 3/3!  Some change I did, and considered unimportant,
actually seems to have had important repercussions.  It it the
non-const shrink and expand?  I tried changing that back and nothing
would do.  Could be the non-global-const n...  I think I'll just have
to live with it, since the non-const n is pretty essential.

=========================================================

1999/03/10:

Before I make some big changes to the inheritance tree, here
are some benchmarks for explicit fixed Euler:

(egcs-2.92.23 19981122 (gcc2 ss-980609 experimental))

tejas:
Program               avg       +/-       min       max     
---------------------------------------------------------
testeulerO            4.160     0.008     4.150     4.170   
testeulerOun          4.163     0.019     4.150     4.190   
testeulerO3un         4.230     0.000     4.230     4.230   
testeulerO2un         4.233     0.019     4.220     4.260   
testeulerO2           4.240     0.008     4.230     4.250   
testeulerO3           4.243     0.005     4.240     4.250   

Weird progression!  Same programs on zuni:

Program               avg       +/-       min       max     
---------------------------------------------------------
testeulerO2un         3.170     0.008     3.160     3.180   
testeulerO3un         3.173     0.005     3.170     3.180   
testeulerO3           3.177     0.005     3.170     3.180   
testeulerO2           3.180     0.014     3.170     3.200   
testeulerO            3.280     0.008     3.270     3.290   
testeulerOun          3.287     0.009     3.280     3.300   

For adaptive Euler:

tejas:
Program               avg       +/-       min       max     
---------------------------------------------------------
testeulerAdO2un       1.357     0.012     1.340     1.370   
testeulerAdO3un       1.377     0.009     1.370     1.390   
testeulerAdO3         1.377     0.012     1.360     1.390   
testeulerAdO2         1.387     0.021     1.360     1.410   
testeulerAdO          1.417     0.012     1.400     1.430   
testeulerAdOun        1.427     0.005     1.420     1.430   

zuni: the first four ar too close to call.
Program               avg       +/-       min       max     
---------------------------------------------------------
testeulerAdO3un       0.990     0.006     0.980     1.000   
testeulerAdO2un       0.990     0.006     0.980     1.000   
testeulerAdO3         0.990     0.006     0.980     1.000   
testeulerAdO2         0.992     0.004     0.990     1.000   
testeulerAdO          1.038     0.004     1.030     1.040   
testeulerAdOun        1.082     0.007     1.070     1.090   

WITH NEW CLASS HIERARCHY:

Fixed Euler:

tejas:
Program               avg       +/-       min       max     
---------------------------------------------------------
testeulerO2           4.120     0.014     4.110     4.140   
testeulerO2un         4.150     0.016     4.130     4.170   
testeulerO3           4.157     0.017     4.140     4.180   
testeulerO3un         4.307     0.017     4.290     4.330   
testeulerOun          4.333     0.005     4.330     4.340   
testeulerO            4.340     0.014     4.320     4.350   

No speed hit on tejas.

zuni:
Program               avg       +/-       min       max     
---------------------------------------------------------
testeulerO2un         3.360     0.008     3.350     3.370   
testeulerO3           3.360     0.000     3.360     3.360   
testeulerO2           3.367     0.005     3.360     3.370   
testeulerO3un         3.370     0.016     3.350     3.390   
testeulerOun          3.557     0.005     3.550     3.560   
testeulerO            3.557     0.009     3.550     3.570   

There's about a 5% speed hit on zuni.


UPDATE: after some tweaking (still for FIXED EULER)

tejas:
Program               avg       +/-       min       max     
---------------------------------------------------------
testeulerO2un         3.970     0.014     3.950     3.980   
testeulerO3           3.980     0.008     3.970     3.990   
testeulerO2           3.993     0.012     3.980     4.010   
testeulerO3un         4.153     0.005     4.150     4.160   
testeulerOun          4.380     0.016     4.360     4.400   
testeulerO            4.407     0.017     4.390     4.430   

zuni:
Program               avg       +/-       min       max     
---------------------------------------------------------
testeulerO2un         2.954     0.005     2.950     2.960   
testeulerO3           2.956     0.005     2.950     2.960   
testeulerO2           2.958     0.004     2.950     2.960   
testeulerO3un         2.960     0.006     2.950     2.970   
testeulerO            3.020     0.009     3.010     3.030   
testeulerOun          3.044     0.005     3.040     3.050   

Now both tejas and zuni have sped up!  All I did was to remove
func as a member of Euler, since it doesn't need it.

ADAPTIVE EULER:

tejas:
Program               avg       +/-       min       max     
---------------------------------------------------------
testeulerAdO3         1.353     0.009     1.340     1.360   
testeulerAdO2un       1.363     0.005     1.360     1.370   
testeulerAdO3un       1.367     0.005     1.360     1.370   
testeulerAdO2         1.400     0.008     1.390     1.410   
testeulerAdO          1.403     0.017     1.380     1.420   
testeulerAdOun        1.420     0.014     1.410     1.440   

zuni:
Program               avg       +/-       min       max     
---------------------------------------------------------
testeulerAdO3un       1.038     0.010     1.020     1.050   
testeulerAdO2un       1.040     0.011     1.020     1.050   
testeulerAdO2         1.040     0.000     1.040     1.040   
testeulerAdO3         1.042     0.007     1.030     1.050   
testeulerAdO          1.080     0.000     1.080     1.080   
testeulerAdOun        1.120     0.013     1.110     1.140   

No real speedup on tejas, slight slowdown on zuni.  That's weird,
since there was already a function call in the adaptive routine!

FIXED RK4:

zuni: (NEW CLASS STRUCTURE)
Program               avg       +/-       min       max     
---------------------------------------------------------
testrk4O              0.944     0.008     0.940     0.960   
testrk4Oun            0.946     0.005     0.940     0.950   
testrk4O3             0.952     0.007     0.940     0.960   
testrk4O2             0.952     0.004     0.950     0.960   
testrk4O2un           0.956     0.005     0.950     0.960   
testrk4O3un           0.956     0.005     0.950     0.960   

zuni: (OLD CLASS STRUCTURE)
Program               avg       +/-       min       max     
---------------------------------------------------------
testrk4_oldOun        0.848     0.004     0.840     0.850   
testrk4_oldO          0.852     0.010     0.840     0.870   
testrk4_oldO2un       0.874     0.005     0.870     0.880   
testrk4_oldO2         0.874     0.005     0.870     0.880   
testrk4_oldO3un       0.876     0.005     0.870     0.880   
testrk4_oldO3         0.878     0.007     0.870     0.890   

Wow! Noticeably worse!  Where does all this overhead come from?

Here are the KCC results on zuni:

Program               avg       +/-       min       max     
---------------------------------------------------------
testrk4_oldKCC        0.932     0.007     0.920     0.940   
testrk4KCC            1.006     0.005     1.000     1.010   
testrk4kcc            1.022     0.004     1.020     1.030   
testrk4_oldkcc        1.024     0.005     1.020     1.030   

ADAPTIVE RK4:

zuni: (NEW CLASS STRUCTURE)
Program               avg       +/-       min       max     
---------------------------------------------------------
testrk4_newO2         0.172     0.004     0.170     0.180   
testrk4_newO3         0.172     0.004     0.170     0.180   
testrk4_newO          0.174     0.005     0.170     0.180   
testrk4_newO3unroll   0.174     0.005     0.170     0.180   
testrk4_newO2unroll   0.176     0.008     0.170     0.190   
testrk4_newOunroll    0.180     0.000     0.180     0.180   
testrk4_newunopt      0.982     0.012     0.970     1.000   

zuni: (OLD CLASS STRUCTURE)
Program               avg       +/-       min       max     
---------------------------------------------------------
testrk4_oldO3unroll   0.166     0.005     0.160     0.170   
testrk4_oldO2         0.168     0.004     0.160     0.170   
testrk4_oldO3         0.168     0.004     0.160     0.170   
testrk4_oldO2unroll   0.170     0.000     0.170     0.170   
testrk4_oldO          0.172     0.004     0.170     0.180   
testrk4_oldOunroll    0.178     0.004     0.170     0.180   
testrk4_oldunopt      0.982     0.004     0.980     0.990   

The new structure is slower.
The differemce is between 3-4%.

With KCC, the difference is much less significant:

(tejas)
Program               avg       +/-       min       max     
---------------------------------------------------------
testrk4_newKCC        0.355     0.007     0.350     0.370   
testrk4_oldKCC        0.359     0.005     0.350     0.370   

This was for relatively short integration.  For longer times,
we get

tejas:
Program               avg       +/-       min       max     
---------------------------------------------------------
testrk4_newKCC        2.723     0.011     2.710     2.740   
testrk4_oldKCC        2.765     0.012     2.750     2.790   

zuni:
Program               avg       +/-       min       max     
---------------------------------------------------------
testrk4_oldKCC        2.078     0.006     2.070     2.090   
testrk4_newKCC        2.089     0.005     2.080     2.100   

egcs zuni:

Program               avg       +/-       min       max     
---------------------------------------------------------
testrk4_newO2unroll   1.503     0.009     1.490     1.510   
testrk4_newO2         1.507     0.005     1.500     1.510   
testrk4_newO3         1.507     0.005     1.500     1.510   
testrk4_newO3unroll   1.517     0.017     1.500     1.540   
testrk4_newO          1.560     0.000     1.560     1.560   
testrk4_newOunroll    1.587     0.005     1.580     1.590   
testrk4_newKCC        2.087     0.009     2.080     2.100   
testrk4_newunopt      9.600     0.008     9.590     9.610   

Program               avg       +/-       min       max     
---------------------------------------------------------
testrk4_oldO2unroll   1.477     0.005     1.470     1.480   
testrk4_oldO2         1.487     0.009     1.480     1.500   
testrk4_oldO3unroll   1.487     0.009     1.480     1.500   
testrk4_oldO3         1.487     0.009     1.480     1.500   
testrk4_oldO          1.517     0.005     1.510     1.520   
testrk4_oldOunroll    1.543     0.009     1.530     1.550   
testrk4_oldKCC        2.080     0.008     2.070     2.090   
testrk4_oldunopt      9.620     0.008     9.610     9.630   

The difference is now of the order of 1-2%.

The elegance of the new structure will have to win over the small loss
in speed!

But wait... if I move the member T_func& func from the derived to the
base, good things happen.

egcs zuni:
Program               avg       +/-       min       max     
---------------------------------------------------------
testrk4_newO3         1.480     0.008     1.470     1.490   
testrk4_newO3unroll   1.480     0.008     1.470     1.490   
testrk4_newO2unroll   1.483     0.005     1.480     1.490   
testrk4_newO2         1.487     0.005     1.480     1.490   
testrk4_newO          1.553     0.005     1.550     1.560   
testrk4_newOunroll    1.570     0.000     1.570     1.570   
testrk4_newKCC        2.090     0.008     2.080     2.100   
testrk4_newunopt      9.693     0.005     9.690     9.700   

Pretty much the same now! Similarly for KCC, which is now faster:

Program               avg       +/-       min       max     
---------------------------------------------------------
testrk4_newKCC        2.054     0.005     2.050     2.060   
testrk4_oldKCC        2.074     0.005     2.070     2.080   

=========================================================

1999/03/23

AdaptiveKapsRentrop: error seems to scale as h.

1       -1.258180604e-08        0.001077736769
0.1     -3.21476179e-12 	0.0105695062
0.01    -3.010924843e-13        0.08720799349
0.001   -2.997602166e-14        0.1545580724
0.0001  -2.886579864e-15        0.0004102331953
1e-05   -2.220446049e-16        1.01147799e-08

Compare with AdaptiveImplicitEuler, which has a perfect
second order scaling (error goes as h^3):

1.      -2.1554719230e-04       -9.9910032991e-05
0.1     -1.7089745818e-07       -9.9103290320e-04
0.01    -1.670841243e-10        -0.009132055074
0.001   -1.663114091e-13        -0.03539893528
